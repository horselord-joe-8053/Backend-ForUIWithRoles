const Logger = require('./logger');

// jjw: https://stackoverflow.com/a/67679003
module.exports = {
  getDateWithZeroTimeFromDateOnlyStr,
  getDerivedScheduledDates,
  // getScheduledDatesWithIntervalInMonth,
  // getScheduledDatesWithIntervalInFortnight: getScheduledDatesWithIntervalInFortnight,
  // getScheduledDatesWithIntervalInFourWeeks,
  getDateIncremented,
  getDateIncrementedByDays,
  getDateIncrementedByHours,
  getDateIncrementedBySeconds,
  toISODateWithoutTimeString,
  DATE_SHIFTKEY_DELIMITER: '_',

  getPrevScheduledDateList,
};

// export const DateUtils = {
//   inSeconds,
//   inMinutes,
//   inHours,
//   inDays: inDaysFrac,
//   inWeeks: inWeeksFrac,
//   inMonths,
//   inYears,
// };

/*
// jjw: NOTE: we need to do comparison of the Date without the Time
// https://stackoverflow.com/a/29602313
Date.prototype.withoutTime = function () {
  // var d = new Date(this);
  // d.setHours(0, 0, 0, 0);
  // return d;

  // jjw: quite mad, but in our specific application, we never care about the time,
  // so we do this to save the cost of creating a new Date that used above
  this.setHours(0, 0, 0, 0);
  return this;
};
*/
const precision = 4;
const ignorableEpsilon = Math.pow(10, -1 * precision);

function getDateWithZeroTimeFromDateOnlyStr(dateOnlyStr) {
  return new Date(dateOnlyStr);
}

function getDerivedScheduledDates(payFrequency, lastKnowPayDateStr, anchorDateStr) {
  Logger.logAsStr(
    'DerivedValueHandler.getDerivedData',
    'lastKnowPayDate',
    lastKnowPayDateStr,
    'DEBUG'
  );
  Logger.logAsStr(
    'DerivedValueHandler.getDerivedData',
    'anchorDateStr',
    anchorDateStr
    // 'DEBUG' //TODO: recover
  );
  Logger.logAsStr('DerivedValueHandler.getDerivedData', 'payFrequency', payFrequency, 'DEBUG');

  // let secondLastDate = null;
  // let lastDate = null;
  // let nextDate = null;

  let scheduledDates = undefined;
  let lastKnownPayDate = new Date(lastKnowPayDateStr);
  let anchorDate = new Date(anchorDateStr);

  // jjw: inspired by https://stackoverflow.com/a/66446126
  switch (payFrequency.toUpperCase()) {
    // jjw: case param needs to be consistent with the value in
    //    <option value="..." ...> in the config file for the payFrequency field
    case 'FORTNIGHTLY': {
      scheduledDates = getScheduledDatesWithIntervalInWeekWithDate(lastKnownPayDate, 2, anchorDate);
      break;
    }
    case 'EVERY 4 WEEKS': {
      // jjw: We kept the 'value' of Option of the <SELECT/> consistent with display value
      // jjw: only because we want the summary table row shows the same as in the Add/Edit view
      // jjw: and this is the simplest and cleanest way to do it, for now.
      scheduledDates = getScheduledDatesWithIntervalInWeekWithDate(lastKnownPayDate, 4, anchorDate);
      break;
    }
    case 'MONTHLY': {
      scheduledDates = getScheduledDatesWithIntervalInMonthWithDate(lastKnownPayDate, anchorDate);
      break;
    }
    default: {
      Logger.logAsStr(
        'DerivedValueHandler',
        'getDerivedData, switch(), ERROR: unexpected payFrequency value',
        payFrequency,
        'ERROR'
      );
      break;
    }
  }

  Logger.logAsJsonStr(
    'DerivedValueHandler.getDerivedData',
    'scheduledDates',
    scheduledDates,
    'DEBUG'
  );

  return scheduledDates;
}

function getDateIncremented(baseDateObj, frequencyIncrementUnit, numOfIncrementUnits) {
  Logger.logAsStr(
    'date-utils.getDateIncremented',
    `frequencyIncrementUnit:${frequencyIncrementUnit}, numOfIncrementUnits:${numOfIncrementUnits}`,
    ''
  );

  Logger.logAsJsonStr('date-utils.getDateIncremented', 'baseDateObj', baseDateObj);

  var resultDateObj = null;
  switch (frequencyIncrementUnit.toUpperCase()) {
    // jjw: case param needs to be consistent with the value in
    //    <option value="..." ...> in the config file for the payFrequency field
    case 'FORTNIGHTLY': {
      resultDateObj = getDateIncrementedByDays(baseDateObj, 2 * 7 * numOfIncrementUnits);
      break;
    }
    case 'EVERY 4 WEEKS': {
      resultDateObj = getDateIncrementedByDays(baseDateObj, 4 * 7 * numOfIncrementUnits);
      break;
    }
    case 'MONTHLY': {
      resultDateObj = getDateIncrementedByUTCMonths(baseDateObj, numOfIncrementUnits);
      break;
    }
    // TODO: later may need functionality incremented by other frequency such as 'MONTHLY'
    default: {
      Logger.logAsStr(
        'date-utils.getDateIncremented',
        'switch(), ERROR: unexpected frequencyIncrementUnit value',
        frequencyIncrementUnit,
        'ERROR'
      );
      break;
    }
  }

  Logger.logAsJsonStr('date-utils.getDateIncremented', 'resultDateObj', resultDateObj);

  return resultDateObj;
}

// NOTE: if using the following non-UTC based date arithmatic,
//    the calculation result will 'feel the impact' of Daylight Saving Time (DST),
//    Generally Speaking, DST is :
//      https://www.almanac.com/content/when-daylight-saving-time#:~:text=Daylight%20Saving%20Time%20Today&text=Today%2C%20most%20Americans%20spring%20forward,at%202%3A00%20A.M.).
//      Today, most Americans (different in southern hemisphere as as Australia)
//        - spring forward (turn clocks ahead and lose an hour) on the second Sunday in March (at 2:00 A.M.) and
//        - fall back (turn clocks back and gain an hour) on the first Sunday in November (at 2:00 A.M.).
//      e.g. in 2022, in USA, DST
//        - starts on March 13, 2am
//        - ends on November 6, 2am
//    Therefore for example, if we don't use UTC, then try to add 1 month onto Oct 7, 2022 (with time set to 0s),
//      we will get Nov 6 (with time set to 23h), instead desired Nov 7, 2022 (with time set to 0s),
//    But if we use UTC, which doesn't have DST, then the arithmetic will work as expected

// function getDateIncrementedByMonths(baseDateObj, incrementInMonths) {
//   let resultDateObj = new Date(baseDateObj); // make a copy of the base date

//   let baseDateDay = baseDateObj.getDate();

//   resultDateObj.setDate(1); // temp set date to 1 so that we can isolate the month to set
//   resultDateObj.setMonth(baseDateObj.getMonth() + incrementInMonths);

//   let resultMonth = resultDateObj.getMonth();
//   let resultFullYear = resultDateObj.getFullYear();

//   let resultMonthLastDay = getLastDay(resultMonth, resultFullYear);

//   Logger.logAsStr(
//     'date-utils.getDateIncrementedByMonths',
//     `baseDateDay:${baseDateDay}, resultMonth:${resultMonth}, resultFullYear:${resultFullYear}, resultMonthLastDay:${resultMonthLastDay}`,
//     ''
//   );

//   if (baseDateDay >= resultMonthLastDay) {
//     // edge case, last few days of the month, e.g.
//     // baseDateObj = 2021-03-31, baseDateDay = 31
//     // incrementInMonths = -1
//     // resultFullYear = 2021, resultMonth = 1 (Feb), resultMonthLastDay = 28
//     // because 31 > 28
//     // => resultDateObj = 2021-02-28
//     resultDateObj.setDate(resultMonthLastDay);
//   } else {
//     resultDateObj.setDate(baseDateDay);
//   }

//   return resultDateObj;
// }

function getDateIncrementedByUTCMonths(baseDateObj, incrementInMonths) {
  let resultDateObj = new Date(baseDateObj); // make a copy of the base date

  let baseDateDay = baseDateObj.getUTCDate();

  resultDateObj.setUTCDate(1); // temp set date to 1 so that we can isolate the month to set
  resultDateObj.setUTCMonth(baseDateObj.getUTCMonth() + incrementInMonths);

  let resultMonth = resultDateObj.getUTCMonth();
  let resultFullYear = resultDateObj.getUTCFullYear();

  let resultMonthLastDay = getLastDay(resultMonth, resultFullYear);

  Logger.logAsStr(
    'date-utils.getDateIncrementedByMonths',
    `baseDateDay:${baseDateDay}, resultMonth:${resultMonth}, resultFullYear:${resultFullYear}, resultMonthLastDay:${resultMonthLastDay}`,
    ''
  );

  if (baseDateDay >= resultMonthLastDay) {
    // edge case, last few days of the month, e.g.
    // baseDateObj = 2021-03-31, baseDateDay = 31
    // incrementInMonths = -1
    // resultFullYear = 2021, resultMonth = 1 (Feb), resultMonthLastDay = 28
    // because 31 > 28
    // => resultDateObj = 2021-02-28
    resultDateObj.setUTCDate(resultMonthLastDay);
  } else {
    resultDateObj.setUTCDate(baseDateDay);
  }

  return resultDateObj;
}

function getDateIncrementedByDays(baseDate, days) {
  // jjw: NOTE: if we need to ping the hours to be the exactly the same
  // jjw:   when we printout these Date object (which will be in UTC time),
  // jjw:   then we have to use incrememnt on 'Time' not 'Days' or 'Months'
  // jjw:   REASON: Daylight Saving Time (DST)
  // jjw:   UTC doesn't observe DST therefore
  // jjw:   - if you increment by days, it will
  // jjw:     increment to the same local time of the base date, which may have
  // jjw:     crossed DST during this increment hence, when printout to UTC, there
  // jjw:     will be discrepancy of 1h.
  // jjw:   - if you increment by Time, on the other hand, it will be incrementing
  // jjw:     UTC time which ignores DST, hence when printout as UTC time, there
  // jjw:     will be no discrepancy.
  // jjw:   Printout is a trivial issue maybe, but MongoDB is using UTC time internally
  // jjw:     so without the extra layer of logic to handle local, we need our code
  // jjw:     logic to strictly consistent with UTC to do strict comparsion between
  // jjw:     our Date and Date stored in MongoDB with timeportion strictly kept at
  // jjw:     0;
  var date = new Date(baseDate.getTime() + 24 * 3600 * 1000 * days);
  return date;
}

function getDateIncrementedByHours(baseDate, hours) {
  // jjw: NOTE as above func
  var date = new Date(baseDate.getTime() + 1000 * 60 * 60 * hours);
  return date;
}

function getDateIncrementedBySeconds(baseDate, seconds) {
  // jjw: NOTE as above func
  var date = new Date(baseDate.getTime() + 1000 * seconds);
  return date;
}

// https://stackoverflow.com/a/46005119
const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

// isLastDay :: Number, Number -> Boolean
const isLastDay = (d, m, y) => {
  let dm = isLeapYear(y) && m === 1 ? 29 : daysInMonth(m);
  return dm === d;
};

// getLastDay :: Number, Number -> Number
const getLastDay = (m, y) => (isLeapYear(y) && m === 1 ? 29 : daysInMonth[m]);

function isLeapYear(yr) {
  // https://en.wikipedia.org/wiki/Leap_year
  //    each year which is an integer multiple of 4 (except for years evenly divisible by 100, but not by 400)
  // https://stackoverflow.com/a/19570985
  return !(yr % 4 || (!(yr % 100) && yr % 400));
}

function getScheduledDatesWithIntervalInMonthWithDate(knownPrevDate, anchorDate) {
  // jjw: we need to clear the time portion so that the time difference between within the same day that we
  // jjw:   don't care about in this application will not affect the fraction we generate

  // knownPrevDate.setHours(0, 0, 0, 0);

  Logger.logAsJsonStr(
    'date-utils.getScheduledDatesWithIntervalInMonthWithDate',
    'knownPrevDate',
    knownPrevDate,
    'debug'
  );

  var diffInMonthInt = timeBeforeDateInMonthInt(knownPrevDate, anchorDate);
  Logger.logAsStr(
    'date-utils.getScheduledDatesWithIntervalInMonthWithDate',
    'diffInMonthInt',
    diffInMonthInt,
    'debug'
  );

  // caculate the next scheduled date
  // jjw: NOTE: https://stackoverflow.com/a/2706169
  var nextDate = new Date(knownPrevDate); // make a copy from knownPrevDate
  nextDate.setMonth(knownPrevDate.getMonth() + diffInMonthInt); // increment

  // caculate the last scheduled date
  var lastDate = new Date(knownPrevDate); // make a copy from knownPrevDate
  lastDate.setMonth(knownPrevDate.getMonth() + diffInMonthInt - 1);
  if (lastDate < knownPrevDate) {
    // if calculated last scheduled date is still earlier than the last known date, no point to get it
    lastDate = null;
  }

  var secondLastScheduledDate = null;
  if (lastDate > knownPrevDate) {
    // if calculated last scheduled date is no later than the last known date, no point to caculate the 2nd last date
    secondLastScheduledDate = new Date(knownPrevDate);
    secondLastScheduledDate.setMonth(knownPrevDate.getMonth() + diffInMonthInt - 2);
    if (secondLastScheduledDate < knownPrevDate) {
      // if calculated 2nd last scheduled date is still earlier than the last known date, no point to get it
      secondLastScheduledDate = null;
    }
  }
  return {
    secondLastDate: secondLastScheduledDate,
    lastDate: lastDate,
    nextDate: nextDate,
  };
}

function getScheduledDatesWithIntervalInWeekWithDate(knownPrevDate, weeksPerInterval, anchorDate) {
  // jjw: we need to clear the time portion so that the time difference between within the same day that we
  // jjw:   don't care about in this application will not affect the fraction we generate
  Logger.logAsJsonStr(
    'date-utils.getNextScheduledDateWithIntervalInWeekWithDate',
    'knownPrevDate, before set hours to 0',
    knownPrevDate,
    'debug'
  );

  // knownPrevDate.setHours(0, 0, 0, 0);
  // jjw: this will not work in junction with print out the date using JSON.Stringify()
  // jjw: , which seems to use toUTCString() of the date object, not localized
  // jjw: it also seems not necessary in our context

  // jjw: TODO: read more below and find a safer way to do dates
  // jjw: https://stackoverflow.com/a/49407725 (about set hours with toString)
  // jjw: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setHours
  // jjw: TODO: question is that if setHour is set hours in local time, why when it is enabled our result
  // jjw:   is unexpected (or does it just appear so in the log? but why it appears correct without setHour
  // jjw:   in the log?
  // jjw: TODO: more reading:
  // jjw: https://stackoverflow.com/a/63166934 (Aus timezone)
  // jjw: https://stackoverflow.com/a/15171030 (more comprehensive about Date)

  var diffInWeeksFrac = timeBeforeDateInWeeksFrac(knownPrevDate, anchorDate);
  Logger.logAsStr(
    'date-utils.getNextScheduledDateWithIntervalInWeekWithDate',
    'diffInWeeksFrac',
    diffInWeeksFrac,
    'debug'
  );
  var diffInIntervalFrac = diffInWeeksFrac / weeksPerInterval;
  diffInIntervalFrac = ignoreEpsilon(diffInIntervalFrac, ignorableEpsilon, precision);

  var diffInIntervalInt = Math.ceil(diffInIntervalFrac); // NOTE: ceil(1.000) = 1.000
  Logger.logAsStr(
    'date-utils.getNextScheduledDateWithIntervalInWeekWithDate',
    'diffInIntervalInt',
    diffInIntervalInt,
    'debug'
  );

  // caculate the next scheduled date
  // NOTE: see note for caveat in getDateIncrementedByDays()
  // jjw: TODO:
  // 1. on server code here, replace any other
  // setDate(x.getDate() + ...) or
  // setMonth(x.getMonth() + ...)???
  // 2. on UI code, replace similar places
  var nextScheduledDate = getDateIncrementedByDays(
    knownPrevDate,
    diffInIntervalInt * weeksPerInterval * 7
  );

  Logger.logAsJsonStr(
    'date-utils.getNextScheduledDateWithIntervalInWeekWithDate',
    'nextScheduledDate',
    nextScheduledDate,
    'debug'
  );

  // caculate the last scheduled date
  var lastScheduledDate = getDateIncrementedByDays(
    knownPrevDate,
    (diffInIntervalInt - 1) * weeksPerInterval * 7
  );

  if (lastScheduledDate < knownPrevDate) {
    // if calculated last scheduled date is still earlier than the last known date, no point to get it
    lastScheduledDate = null;
  }
  Logger.logAsJsonStr(
    'date-utils.getNextScheduledDateWithIntervalInWeekWithDate',
    'lastScheduledDate',
    lastScheduledDate,
    'debug'
  );

  var secondLastScheduledDate = null;
  if (lastScheduledDate > knownPrevDate) {
    // if calculated last scheduled date is no later than the last known date, no point to caculate the 2nd last date
    secondLastScheduledDate = getDateIncrementedByDays(
      knownPrevDate,
      (diffInIntervalInt - 2) * weeksPerInterval * 7
    );

    if (secondLastScheduledDate < knownPrevDate) {
      // if calculated 2nd last scheduled date is still earlier  than the last known date, no point to get it
      secondLastScheduledDate = null;
    }
  }
  Logger.logAsJsonStr(
    'date-utils.getNextScheduledDateWithIntervalInWeekWithDate',
    'secondLastScheduledDate',
    secondLastScheduledDate,
    'debug'
  );

  return {
    secondLastDate: secondLastScheduledDate,
    lastDate: lastScheduledDate,
    nextDate: nextScheduledDate,
  };
}

function timeBeforeDateInWeeksFrac(prevDate, anchorDate) {
  var anchorDateCp = new Date(anchorDate.valueOf());
  anchorDateCp.setHours(0, 0, 0, 0);

  var diffInWeeks = inWeeksFrac(prevDate, anchorDateCp);

  return ignoreEpsilon(diffInWeeks, ignorableEpsilon, precision);
}

// function timeBeforeNowInWeeksFrac(prevDate) {
//   var now = new Date();
//   now.setHours(0, 0, 0, 0);

//   var diffInWeeks = inWeeksFrac(prevDate, now);

//   return ignoreEpsilon(diffInWeeks, ignorableEpsilon, precision);
// }

function timeBeforeDateInMonthInt(prevDate, anchorDate) {
  var anchorDateCp = new Date(anchorDate.valueOf()); // in case the original param var will be used by calling function
  anchorDateCp.setHours(0, 0, 0, 0);

  var diffInMonths = inMonths(prevDate, anchorDateCp);

  if (diffInMonths % 12 === 0) {
    // if the prevDate and anchorDate are in the same month
    // e.g. if anchorDate is July 20, 2021
    // - if prevDate is July 10, 2020, then the 'next date' from anchorDate's point of view, should be Aug 10, 2020
    if (prevDate.getDate() < anchorDateCp.getDate()) {
      // - if prevDate is July 10, 2020, then the 'next date' from anchorDate's point of view,
      //    should be incremented by one month to Aug 10, 2021
      Logger.logAsStr(
        'date-utils.timeBeforeDateInMonthInt',
        `${prevDate.getDate()} < ${anchorDateCp.getDate()}`,
        ', increment'
      );
      diffInMonths++;
    } else if (prevDate.getDate() === anchorDateCp.getDate()) {
      // - if prevDate is also July 20, but in 2020, then we deem
      //  the difference in months is 12, not 13
      Logger.logAsStr(
        'date-utils.timeBeforeDateInMonthInt',
        `${prevDate.getDate()} ===  ${anchorDateCp.getDate()}`,
        ', no increment'
      );
      // keep diff as it is
    } else {
      // - if prevDate is July 30, 2020, then the 'next date' from anchorDate point of view,
      //    should be July 30, 2021
      Logger.logAsStr(
        'date-utils.timeBeforeDateInMonthInt',
        `${prevDate.getDate()} > ${anchorDateCp.getDate()}`,
        ', no increment'
      );
      // keep diff as it is
    }
  }

  if (diffInMonths < 0) {
    Logger.logAsStr(
      'date-utils.timeBeforeDateInMonthInt',
      `Unexpected negative diffInMonths: ${diffInMonths}, set it to 0`,
      '',
      'WARNING'
    );
    diffInMonths = 0;
  }

  return diffInMonths;
}

// function timeBeforeNowInMonthInt(prevDate) {
//   var now = new Date();
//   now.setHours(0, 0, 0, 0);

//   var diffInMonths = inMonths(prevDate, now);

//   return diffInMonths;
// }

function ignoreEpsilon(fraction, epsilon, prec) {
  // jjw: the purpose of this function is to
  // jjw:   'smooth' the episilon resulted from fraction caculation
  // jjw:   so that these episilon will not result in 'one off' error for us
  let result = fraction;
  if (fraction - Math.floor(fraction) < epsilon) {
    result = Math.floor(fraction).toFixed(prec);
  } else if (Math.ceil(fraction) - fraction < epsilon) {
    result = Math.ceil(fraction).toFixed(prec);
  }
  return result;
}

function toISODateWithoutTimeString(date) {
  let result = '';
  if (isString(date)) {
    result = new Date(date).toISOString().split('T')[0];
  } else if (isDateObj(date)) {
    result = date.toISOString().split('T')[0];
    // result = date.toLocaleDateString();
  } else {
    Logger.logAsJsonStr(
      'date-utils.toDateString',
      'Unexpected Error: the object representing date is neither a date object or a string:',
      date
    );
  }
  return result;
}

function isString(obj) {
  // jjw: NOTE: check if it is a string: https://stackoverflow.com/a/9436948
  return typeof obj === 'string' || obj instanceof String;
}

function isDateObj(obj) {
  // jjw: NOTE: check if it is a Date object: https://stackoverflow.com/a/643827
  return Object.prototype.toString.call(obj) === '[object Date]';
}

function inSeconds(d1, d2) {
  var t2 = d2.getTime();
  var t1 = d1.getTime();

  return parseInt((t2 - t1) / 1000);
}

function inMinutes(d1, d2) {
  var t2 = d2.getTime();
  var t1 = d1.getTime();

  return parseInt((t2 - t1) / 60000);
}

function inHours(d1, d2) {
  var t2 = d2.getTime();
  var t1 = d1.getTime();

  return parseInt((t2 - t1) / 3600000);
}

function inDaysFrac(d1, d2) {
  var t2 = d2.getTime();
  var t1 = d1.getTime();

  return parseFloat((t2 - t1) / (24 * 3600 * 1000)).toFixed(precision);
}

function inWeeksFrac(d1, d2) {
  var t2 = d2.getTime();
  var t1 = d1.getTime();

  // return parseInt((t2 - t1) / (24 * 3600 * 1000 * 7));
  return parseFloat((t2 - t1) / (24 * 3600 * 1000 * 7)).toFixed(precision);
}

function inMonths(d1, d2) {
  var d1Y = d1.getFullYear();
  var d2Y = d2.getFullYear();
  var d1M = d1.getMonth();
  var d2M = d2.getMonth();

  return d2M + 12 * d2Y - (d1M + 12 * d1Y);
}

function inYears(d1, d2) {
  return d2.getFullYear() - d1.getFullYear();
}

// ----------
function getPrevScheduledDateList(payFrequency, lastKnownPayDateStr, anchorDateStr) {
  Logger.logAsStr(
    'date-utils.getPrevScheduledDateList',
    'lastKnownPayDate',
    lastKnownPayDateStr
    // 'DEBUG'
  );
  Logger.logAsStr(
    'date-utils.getPrevScheduledDateList',
    'anchorDateStr',
    anchorDateStr
    // 'DEBUG' //TODO: recover
  );
  Logger.logAsStr(
    'date-utils.getPrevScheduledDateList',
    'payFrequency',
    payFrequency
    // 'DEBUG'
  );

  // let secondLastDate = null;
  // let lastDate = null;
  // let nextDate = null;

  let prevScheduledDateList = undefined;

  let lastKnownPayDate = new Date(lastKnownPayDateStr);
  let anchorDate = new Date(anchorDateStr);

  // jjw: inspired by https://stackoverflow.com/a/66446126
  switch (payFrequency.toUpperCase()) {
    // jjw: case param needs to be consistent with the value in
    //    <option value="..." ...> in the config file for the payFrequency field
    case 'FORTNIGHTLY': {
      prevScheduledDateList = getPrevScheduledDateListWithIntervalInWeeks(
        lastKnownPayDate,
        2,
        anchorDate
      );
      break;
    }
    case 'EVERY 4 WEEKS': {
      // jjw: We kept the 'value' of Option of the <SELECT/> consistent with display value
      // jjw: only because we want the summary table row shows the same as in the Add/Edit view
      // jjw: and this is the simplest and cleanest way to do it, for now.
      prevScheduledDateList = getPrevScheduledDateListWithIntervalInWeeks(
        lastKnownPayDate,
        4,
        anchorDate
      );
      break;
    }
    case 'MONTHLY': {
      prevScheduledDateList = getPrevScheduledDateListWithIntervalInMonths(
        lastKnownPayDate,
        anchorDate
      );
      break;
    }
    default: {
      Logger.logAsStr(
        'date-utils.getPrevScheduledDateList',
        'switch(), ERROR: unexpected payFrequency value',
        payFrequency,
        'ERROR'
      );
      break;
    }
  }

  Logger.logAsJsonStr(
    'date-utils.getPrevScheduledDateList',
    'scheduledDates',
    prevScheduledDateList,
    'DEBUG'
  );

  return prevScheduledDateList;
}

function getPrevScheduledDateListWithIntervalInWeeks(knownPrevDate, weeksPerInterval, anchorDate) {
  // jjw: we need to clear the time portion so that the time difference between within the same day that we
  // jjw:   don't care about in this application will not affect the fraction we generate
  Logger.logAsJsonStr(
    'date-utils.getScheduledDateListWithIntervalInWeeks',
    'knownPrevDate, before set hours to 0',
    knownPrevDate,
    'debug'
  );

  var diffInWeeksFrac = timeBeforeDateInWeeksFrac(knownPrevDate, anchorDate); // e.g. 7.3
  Logger.logAsStr(
    'date-utils.getScheduledDateListWithIntervalInWeeks',
    'diffInWeeksFrac',
    diffInWeeksFrac,
    'debug'
  );
  var diffInIntervalFrac = diffInWeeksFrac / weeksPerInterval; // e.g. 7.3/2 = 3.65000
  diffInIntervalFrac = ignoreEpsilon(diffInIntervalFrac, ignorableEpsilon, precision); // 3.65

  var diffInIntervalInt = Math.ceil(diffInIntervalFrac); // e.g. 4.00,  NOTE: ceil(1.000) = 1.000

  Logger.logAsStr(
    'date-utils.getScheduledDateListWithIntervalInWeeks',
    'diffInIntervalInt',
    diffInIntervalInt,
    'debug'
  );

  let isOnTheScheduledDate = diffInIntervalInt === diffInIntervalFrac;

  let prevAllScheduledDateList = [];
  for (let i = 0; i <= diffInIntervalInt; i++) {
    let nextScheduledDate = getDateIncrementedByDays(knownPrevDate, i * weeksPerInterval * 7);

    if (i < diffInIntervalInt) {
      prevAllScheduledDateList.push(nextScheduledDate);
    } else {
      // for the last scheduledDate, only push to the list
      //  if it is the same date as the anchorDate.
      //  i.e. from anchorDate's point of view, itself should already be
      //  in the past
      if (isSameDay(nextScheduledDate, anchorDate)) {
        prevAllScheduledDateList.push(nextScheduledDate);
      }
    }
  }
  if (isOnTheScheduledDate) {
    prevAllScheduledDateList.push(anchorDate);
  }

  Logger.logAsJsonStr(
    'date-utils.getScheduledDateListWithIntervalInWeeks',
    'prevAllScheduledDateList',
    prevAllScheduledDateList
  );

  return prevAllScheduledDateList;
}

function isSameDay(d1, d2) {
  // let result = (d1.getDate() === d2.getDate()) && (d1.getMonth() === d2.getMonth()) && (d1.getFullYear() === d2.getFullYear());
  let result = d1.toDateString() === d2.toDateString();
  Logger.logAsStr('date-utils.isSameDay', 'result', result);
  return result;
}

function getPrevScheduledDateListWithIntervalInMonths(knownPrevDate, anchorDate) {
  // jjw: we need to clear the time portion so that the time difference between within the same day that we
  // jjw:   don't care about in this application will not affect the fraction we generate

  // knownPrevDate.setHours(0, 0, 0, 0);

  Logger.logAsJsonStr(
    'date-utils.getPrevScheduledDateListWithIntervalInMonths',
    'knownPrevDate',
    knownPrevDate
    // 'debug'
  );

  var diffInMonthInt = timeBeforeDateInMonthInt(knownPrevDate, anchorDate);
  Logger.logAsStr(
    'date-utils.getPrevScheduledDateListWithIntervalInMonths',
    'diffInMonthInt',
    diffInMonthInt
    // 'debug'
  );

  let prevScheduledDateList = [];
  for (let i = 0; i <= diffInMonthInt; i++) {
    // if the nextScheduledDate and anchorDate are the same day,
    // we will include the anchorDate on the list too.
    // let nextScheduledDate = getDateIncrementedByMonths(knownPrevDate, i);
    let nextScheduledDate = getDateIncrementedByUTCMonths(knownPrevDate, i);
    prevScheduledDateList.push(nextScheduledDate);
  }

  Logger.logAsJsonStr(
    'date-utils.getPrevScheduledDateListWithIntervalInMonths',
    'prevScheduledDateList',
    prevScheduledDateList
  );

  return prevScheduledDateList;
}
