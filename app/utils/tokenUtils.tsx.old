import {CookieOptions, Response} from 'express'
import jwt from 'jsonwebtoken'

import {
  AccessToken,
  AccessTokenPayload,
  Cookies,
  RefreshToken,
  RefreshTokenPayload,
  UserDocument,
} from './shared/index.ts.old'

import * as authConfig from '../config/auth.config'

// const logger = require("../utils/logger");
import * as logger from './logger';

// jjw: https://www.youtube.com/watch?v=xMsJPnjiRAc

enum TokenExpiration {
  Access = 5 * 60,
  Refresh = 7 * 24 * 60 * 60,
  RefreshIfLessThan = 4 * 24 * 60 * 60,
}

function signAccessToken(payload: any) {
  return jwt.sign(payload, authConfig.accessTokenSecret, {expiresIn: TokenExpiration.Access})
}

function signRefreshToken(payload: any) {
  return jwt.sign(payload, authConfig.refreshTokenSecret, {expiresIn: TokenExpiration.Refresh})
}

const defaultCookieOptions: CookieOptions = {
  // jjw: TODO! enable the rest later
  httpOnly: true,
  // secure: authConfig.isProduction,
  // sameSite: authConfig.isProduction ? 'strict' : 'lax',
  // domain: authConfig.baseDomain,
  // path: '/',
}

const refreshTokenCookieOptions: CookieOptions = {
  ...defaultCookieOptions,
  maxAge: TokenExpiration.Refresh * 1000,
}

const accessTokenCookieOptions: CookieOptions = {
  ...defaultCookieOptions,
  maxAge: TokenExpiration.Access * 1000,
}

export function verifyRefreshToken(token: string) {
  return jwt.verify(token, authConfig.refreshTokenSecret) as RefreshToken
}

export function verifyAccessToken(token: string) {
  try {
    return jwt.verify(token, authConfig.accessTokenSecret) as AccessToken
  } catch (e) {}
}

export function buildTokens(user: any, loginSessionId: string) {
  const accessPayload: any = {
      "userId": user._id, 
      // "loginSessionId": loginSessionId, 
      // "loginSessionVersion": user.loginSessions[loginSessionId]
    }
  
  const refreshPayload: any = {
    "userId": user._id, 
    "loginSessionId": loginSessionId, 
    "loginSessionVersion": user.loginSessions[loginSessionId]
  }

  const accessToken = signAccessToken(accessPayload)
  const refreshToken = refreshPayload && signRefreshToken(refreshPayload)

  return {accessToken, refreshToken}
}

export function setTokens(res: Response, access: string, refresh?: string) {
  res.cookie(Cookies.AccessToken, access, accessTokenCookieOptions)
  // jjw: only update the refreshToken in the cookie if it is defined
  if (refresh) res.cookie(Cookies.RefreshToken, refresh, refreshTokenCookieOptions)
}

export function refreshTokens(currentRefreshToken: any, loginSessionId: string, storedTokenVersion : string) {
  // jjw: request of '/logout-all' will trigger
  // jjw:    const result = await coll.findOneAndUpdate({id: userId}, {$inc: {tokenVersion: 1}})
  logger.logAsJsonStr("token-utils.refreshTokens", "currentRefreshToken", currentRefreshToken);
  logger.logAsStr("token-utils.refreshTokens", "loginSessionId", loginSessionId);
  logger.logAsStr("token-utils.refreshTokens", "storedTokenVersion", storedTokenVersion);

  if (currentRefreshToken.loginSessionVersion !== storedTokenVersion) {
    logger.logAsStr("token-utils.refreshTokens", "!==", "version not matching!");
    
    // jjw: Need to do more
    // TODO: here!! remove the entire loginSession entry from the user
    // op1: throw exception and catch at outter level
    // op2: pass in User model and do it here.
    // TODO: below shouldn't be relevant anymore, we need to return somehow???

    throw authConfig.versionMismatchErrorMsg;
  }

  // -- 1. Create refreshPayload + Sign it to restart its expiration cycle
  let refreshPayload: any | undefined
  // jjw: ??? current.exp ???
  // jjw: the 'current' was generated by jwt.verify(token, config.refreshTokenSecret) as RefreshToken
  // jjw:   , where the jwt.verify will return the object below which, besides the payload object
  // jjw:   we defined (RefreshTokenPayload)
  // jjw:   also a 'exp' indicating the time by which the JWT token will expire (which makes up the extra
  // jjw:   field of RefreshToken comparing to RefreshTokenPayload)
  /*
  export interface JwtPayload {
    [key: string]: any;
    iss?: string | undefined;
    sub?: string | undefined;
    aud?: string | string[] | undefined;
    exp?: number | undefined;
    nbf?: number | undefined;
    iat?: number | undefined;
    jti?: string | undefined;
  } 
  */
  const expiration = new Date(currentRefreshToken.exp * 1000)
  const now = new Date()
  const secondsUntilExpiration = (expiration.getTime() - now.getTime()) / 1000

  if (secondsUntilExpiration < TokenExpiration.RefreshIfLessThan) {
    // jjw: only if the refreshToken is going to expire sooner than the threshold
    // jjw:   (in this config, 4 days while refreshToken is set with life span of 7 days)
    // jjw: , then we will form a new payload and hence a new refreshToken
    // jjw:   (with Ttl changed to start from Full again)
    refreshPayload = {
      "userId": currentRefreshToken.userId, 
      "loginSessionId": loginSessionId, 
      "loginSessionVersion": storedTokenVersion
    }
  }
  // jjw: otherwise, refreshPayload here will be undefined
  const refreshToken = refreshPayload && signRefreshToken(refreshPayload)
  // jjw: NOTE: refreshPayload could be undefined if the refreshToken is NOT
  // jjw:   going to expire sooner than the threshold
  // jjw:   --> leads to refreshToken undefined

  // -- 2. Create accessPayload + Sign it to restart its expiration cycle
  const accessPayload: any = {userId: currentRefreshToken.userId}
  const accessToken = signAccessToken(accessPayload)

  // jjw: caller of this function will have to deal with the situation where
  // jjw:   refreshToken is undefined
  return {accessToken, refreshToken}
}

export function clearTokens(res: Response) {
  res.cookie(Cookies.AccessToken, '', {...defaultCookieOptions, maxAge: 0})
  res.cookie(Cookies.RefreshToken, '', {...defaultCookieOptions, maxAge: 0})
}
